"""
FastAPI Backend for VOSE Movies
Serves cached movie showtime data to mobile app
"""
from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from contextlib import asynccontextmanager
import os
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from dotenv import load_dotenv
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

from api.database.config import init_db
from api.routers import movies, cinemas, showtimes, scraper
from api.exceptions import register_exception_handlers

load_dotenv()


class CacheControlMiddleware(BaseHTTPMiddleware):
    """
    Middleware to add HTTP caching headers to responses

    Cache durations:
    - Showtimes: 10 minutes (stale-while-revalidate for 1 hour)
    - Cinemas: 1 day (rarely change)
    - Movies: 6 hours (metadata updates occasionally)
    - Health/Root: No cache
    """

    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)

        # Only cache GET requests
        if request.method != "GET":
            return response

        path = request.url.path

        # Determine cache duration based on endpoint
        if path.startswith("/showtimes"):
            # Showtimes change frequently - cache for 10 minutes
            # Allow serving stale for 1 hour while revalidating
            response.headers["Cache-Control"] = "public, max-age=600, stale-while-revalidate=3600"
        elif path.startswith("/cinemas"):
            # Cinemas rarely change - cache for 1 day
            response.headers["Cache-Control"] = "public, max-age=86400"
        elif path.startswith("/movies"):
            # Movies metadata updates occasionally - cache for 6 hours
            response.headers["Cache-Control"] = "public, max-age=21600"
        elif path in ["/", "/health"]:
            # Health check and root - no cache
            response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
        else:
            # Default: short cache for unknown endpoints
            response.headers["Cache-Control"] = "public, max-age=300"

        # Add ETag support for better cache validation
        # (ETag will be automatically generated by Starlette based on response body)

        return response


def setup_logging():
    """
    Configure logging for the application with rotating file handler

    Logs are written to logs/api.log with:
    - Max size: 10MB per file
    - Backup count: 5 files
    - Format: timestamp, level, module, message
    """
    # Create logs directory if it doesn't exist
    log_dir = Path(__file__).parent.parent / "logs"
    log_dir.mkdir(exist_ok=True)

    log_file = log_dir / "api.log"

    # Configure log format
    log_format = "%(asctime)s - %(levelname)s - %(name)s - %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"

    # Create rotating file handler (10MB max, keep 5 backups)
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=10 * 1024 * 1024,  # 10MB
        backupCount=5,
        encoding="utf-8"
    )
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(logging.Formatter(log_format, date_format))

    # Console handler for development
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_handler.setFormatter(logging.Formatter(log_format, date_format))

    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)

    # Set specific log levels for different modules
    logging.getLogger("uvicorn").setLevel(logging.INFO)
    logging.getLogger("uvicorn.access").setLevel(logging.INFO)
    logging.getLogger("api").setLevel(logging.INFO)
    logging.getLogger("sqlalchemy.engine").setLevel(logging.WARNING)  # Reduce SQL verbosity

    # Log startup message
    logger = logging.getLogger(__name__)
    logger.info("Logging configured - writing to %s", log_file)

    return logger


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Initialize database and logging on startup"""
    logger = setup_logging()
    logger.info("Starting VOSE Movies API...")
    init_db()
    logger.info("Database initialized")
    yield
    logger.info("Shutting down VOSE Movies API...")


app = FastAPI(
    title="VOSE Movies API",
    description="REST API for VOSE movie showtimes in the Balearic Islands",
    version="1.0.0",
    lifespan=lifespan
)

# Rate limiting configuration
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# CORS configuration for mobile app
# Environment-aware: strict in production, permissive in development
def get_cors_origins():
    """Get CORS origins from environment or use defaults"""
    env = os.getenv("ENVIRONMENT", "development").lower()
    cors_origins_env = os.getenv("CORS_ORIGINS", "")

    if cors_origins_env:
        # Use explicitly configured origins (comma-separated)
        return cors_origins_env.split(",")

    if env == "production":
        # Production: Require explicit CORS_ORIGINS configuration
        print("âš ï¸  WARNING: Running in production mode without CORS_ORIGINS configured!")
        print("âš ï¸  Set CORS_ORIGINS in .env to whitelist your frontend domain")
        return []  # Deny all origins by default in production

    # Development: Allow common development origins
    return [
        "http://localhost:8081",      # Expo web
        "http://localhost:19006",     # Expo web alternative
        "http://localhost:19000",     # Expo DevTools
        "http://10.0.2.2:8081",       # Android emulator
        "http://127.0.0.1:8081",      # Localhost alternative
    ]

cors_origins = get_cors_origins()
env_mode = os.getenv("ENVIRONMENT", "development")

if cors_origins:
    print(f"ðŸŒ CORS enabled for {len(cors_origins)} origin(s) [{env_mode} mode]")
    for origin in cors_origins:
        print(f"   âœ“ {origin}")

    app.add_middleware(
        CORSMiddleware,
        allow_origins=cors_origins,
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=["*"],
    )
else:
    print(f"âš ï¸  CORS is DISABLED - no origins whitelisted [{env_mode} mode]")
    print("   Set CORS_ORIGINS in .env for production deployments")

# Add caching middleware
app.add_middleware(CacheControlMiddleware)
print("ðŸ“¦ HTTP caching enabled with endpoint-specific cache durations")

# Register exception handlers for centralized error handling
register_exception_handlers(app)

# Include routers
app.include_router(showtimes.router)
app.include_router(movies.router)
app.include_router(cinemas.router)
app.include_router(scraper.router)


@app.get("/")
@limiter.limit("200/minute")
def root(request: Request):
    """API root endpoint"""
    logger = logging.getLogger(__name__)
    logger.info("Root endpoint accessed from %s", get_remote_address(request))
    return {
        "message": "VOSE Movies API",
        "version": "1.0.0",
        "endpoints": {
            "showtimes": "/showtimes",
            "movies": "/movies",
            "cinemas": "/cinemas",
            "docs": "/docs",
            "health": "/health"
        }
    }


@app.get("/health")
@app.head("/health")  # Support HEAD for UptimeRobot monitoring
@limiter.limit("200/minute")
def health_check(request: Request, response: Response):
    """
    Comprehensive health check endpoint for monitoring

    Checks:
    - API responsiveness
    - Database connectivity
    - Database table existence

    Returns HTTP 200 if healthy, 503 if unhealthy
    """
    from api.database.config import SessionLocal, DATABASE_URL
    from sqlalchemy import text
    import logging

    logger = logging.getLogger(__name__)
    health_status = {
        "status": "healthy",
        "service": "vose-movies-api",
        "version": "1.0.0",
        "checks": {}
    }

    # Check 1: Database connectivity
    db = None
    try:
        db = SessionLocal()
        # Simple query to verify database connection
        result = db.execute(text("SELECT 1")).scalar()
        health_status["checks"]["database"] = {
            "status": "healthy",
            "message": "Database connection successful"
        }
    except Exception as e:
        health_status["status"] = "unhealthy"
        health_status["checks"]["database"] = {
            "status": "unhealthy",
            "message": f"Database connection failed: {str(e)}"
        }
        logger.error(f"Health check database error: {e}")
    finally:
        if db:
            db.close()

    # Check 2: Verify critical tables exist
    try:
        if db is None:
            db = SessionLocal()

        # Check if critical tables exist
        tables_query = text("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public'
            AND table_name IN ('movies', 'cinemas', 'showtimes')
        """) if not DATABASE_URL.startswith("sqlite") else text("""
            SELECT name
            FROM sqlite_master
            WHERE type='table'
            AND name IN ('movies', 'cinemas', 'showtimes')
        """)

        tables = db.execute(tables_query).fetchall()
        table_names = [t[0] for t in tables]

        if len(table_names) >= 3:
            health_status["checks"]["tables"] = {
                "status": "healthy",
                "message": f"All critical tables exist: {', '.join(table_names)}"
            }
        else:
            health_status["status"] = "degraded"
            health_status["checks"]["tables"] = {
                "status": "warning",
                "message": f"Missing tables. Found: {', '.join(table_names) if table_names else 'none'}"
            }
    except Exception as e:
        health_status["status"] = "degraded"
        health_status["checks"]["tables"] = {
            "status": "warning",
            "message": f"Could not verify tables: {str(e)}"
        }
        logger.warning(f"Health check table verification error: {e}")
    finally:
        if db:
            db.close()

    # Check 3: Check if we have recent data (optional warning, not critical)
    try:
        from datetime import datetime, timedelta
        db = SessionLocal()

        # Check if we have showtimes from recent scraping
        from api.models import Showtime
        recent_cutoff = datetime.now() - timedelta(days=7)
        recent_count = db.query(Showtime).filter(
            Showtime.scraped_at >= recent_cutoff
        ).count()

        if recent_count > 0:
            health_status["checks"]["data_freshness"] = {
                "status": "healthy",
                "message": f"Found {recent_count} showtimes from last 7 days"
            }
        else:
            # Not critical, just a warning
            health_status["checks"]["data_freshness"] = {
                "status": "warning",
                "message": "No recent showtimes found. Run scrapers to populate data."
            }
    except Exception as e:
        health_status["checks"]["data_freshness"] = {
            "status": "warning",
            "message": f"Could not check data freshness: {str(e)}"
        }
        logger.warning(f"Health check data freshness error: {e}")
    finally:
        if db:
            db.close()

    # Determine HTTP status code
    if health_status["status"] == "unhealthy":
        response.status_code = 503  # Service Unavailable
    elif health_status["status"] == "degraded":
        response.status_code = 200  # Still operational but with warnings
    else:
        response.status_code = 200  # Healthy

    return health_status


if __name__ == "__main__":
    import uvicorn

    host = os.getenv("API_HOST", "0.0.0.0")
    port = int(os.getenv("API_PORT", 8000))
    reload = os.getenv("API_RELOAD", "True").lower() == "true"

    uvicorn.run(
        "api.main:app",
        host=host,
        port=port,
        reload=reload
    )
